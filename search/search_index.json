{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-inputfilter üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º –ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\" üá∫üá∏ To Citizens of Russia We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" The laminas-inputfilter component can be used to filter and validate generic sets of input data. For instance, you could use it to filter $_GET or $_POST values, CLI arguments, etc. Installation Run the following to install this library: $ composer require laminas/laminas-inputfilter Documentation Browse the documentation online at https://docs.laminas.dev/laminas-inputfilter/ Support Issues Chat Forum","title":"Home"},{"location":"#laminas-inputfilter","text":"","title":"laminas-inputfilter"},{"location":"#_1","text":"–ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\"","title":"üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º"},{"location":"#to-citizens-of-russia","text":"We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" The laminas-inputfilter component can be used to filter and validate generic sets of input data. For instance, you could use it to filter $_GET or $_POST values, CLI arguments, etc.","title":"üá∫üá∏ To Citizens of Russia"},{"location":"#installation","text":"Run the following to install this library: $ composer require laminas/laminas-inputfilter","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.laminas.dev/laminas-inputfilter/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"file-input/","text":"File Upload Input The Laminas\\InputFilter\\FileInput class is a special Input type for uploaded files found in the $_FILES array. While FileInput uses the same interface as Input , it differs in a few ways: It expects the raw value to be in a normalized $_FILES array format. See the PSR-7 Uploaded files chapter for details on how to accomplish this. Diactoros and laminas-http can do this for you. Alternately, you may provide an array of PSR-7 uploaded file instances. The validators are run before the filters (which is the opposite behavior of Input ). This is so that any validation can be run prior to any filters that may rename/move/modify the file; we should not do those operations if the file upload was invalid! Instead of adding a NotEmpty validator, it will (by default) automatically add a Laminas\\Validator\\File\\UploadFile validator. The biggest thing to be concerned about is that if you are using a &lt;input type=\"file\"&gt; element in your form, you will need to use the FileInput instead of Input or else you will encounter issues. Basic Usage Usage of FileInput is essentially the same as Input : use Laminas\\Http\\PhpEnvironment\\Request; use Laminas\\Filter; use Laminas\\InputFilter\\InputFilter; use Laminas\\InputFilter\\Input; use Laminas\\InputFilter\\FileInput; use Laminas\\Validator; // Description text input $description = new Input('description'); // Standard Input type // Filters are run first w/ Input $description -&gt;getFilterChain() -&gt;attach(new Filter\\StringTrim()); // Validators are run second w/ Input $description -&gt;getValidatorChain() -&gt;attach(new Validator\\StringLength(['max' =&gt; 140])); // File upload input $file = new FileInput('file'); // Special File Input type // Validators are run first w/ FileInput $file -&gt;getValidatorChain() -&gt;attach(new Validator\\File\\UploadFile()); // Filters are run second w/ FileInput $file -&gt;getFilterChain() -&gt;attach(new Filter\\File\\RenameUpload([ 'target' =&gt; './data/tmpuploads/file', 'randomize' =&gt; true, ])); // Merge $_POST and $_FILES data together $request = new Request(); $postData = array_merge_recursive( $request-&gt;getPost()-&gt;toArray(), $request-&gt;getFiles()-&gt;toArray() ); $inputFilter = new InputFilter(); $inputFilter -&gt;add($description) -&gt;add($file) -&gt;setData($postData); if ($inputFilter-&gt;isValid()) { // FileInput validators are run, but not the filters... echo \"The form is valid\\n\"; $data = $inputFilter-&gt;getValues(); // This is when the FileInput filters are run. } else { echo \"The form is not valid\\n\"; foreach ($inputFilter-&gt;getInvalidInput() as $error) { print_r ($error-&gt;getMessages()); } } PSR-7 Support Available since version 2.9.0 You may also pass an array of uploaded files from a PSR-7 ServerRequestInterface . use Psr\\Http\\Message\\ServerRequestInterface; use Laminas\\Filter; use Laminas\\InputFilter\\InputFilter; use Laminas\\InputFilter\\FileInput; use Laminas\\Validator; // File upload input $file = new FileInput('file'); $file -&gt;getValidatorChain() -&gt;attach(new Validator\\File\\UploadFile()); $file -&gt;getFilterChain() -&gt;attach(new Filter\\File\\RenameUpload([ 'target' =&gt; './data/tmpuploads/file', 'randomize' =&gt; true, ])); // Merge form and uploaded file data together // Unlike the previous example, we get the form data from `getParsedBody()`, and // the uploaded file data from `getUploadedFiles()`. // @var ServerRequestInterface $request $postData = array_merge_recursive( $request-&gt;getParsedBody(), $request-&gt;getUploadedFiles() ); $inputFilter = new InputFilter(); $inputFilter -&gt;add($file) -&gt;setData($postData); if ($inputFilter-&gt;isValid()) { // FileInput validators are run, but not the filters... echo \"The form is valid\\n\"; $data = $inputFilter-&gt;getValues(); // This is when the FileInput filters are run. } else { echo \"The form is not valid\\n\"; foreach ($inputFilter-&gt;getInvalidInput() as $error) { print_r ($error-&gt;getMessages()); } }","title":"File Upload Input"},{"location":"file-input/#file-upload-input","text":"The Laminas\\InputFilter\\FileInput class is a special Input type for uploaded files found in the $_FILES array. While FileInput uses the same interface as Input , it differs in a few ways: It expects the raw value to be in a normalized $_FILES array format. See the PSR-7 Uploaded files chapter for details on how to accomplish this. Diactoros and laminas-http can do this for you. Alternately, you may provide an array of PSR-7 uploaded file instances. The validators are run before the filters (which is the opposite behavior of Input ). This is so that any validation can be run prior to any filters that may rename/move/modify the file; we should not do those operations if the file upload was invalid! Instead of adding a NotEmpty validator, it will (by default) automatically add a Laminas\\Validator\\File\\UploadFile validator. The biggest thing to be concerned about is that if you are using a &lt;input type=\"file\"&gt; element in your form, you will need to use the FileInput instead of Input or else you will encounter issues.","title":"File Upload Input"},{"location":"file-input/#basic-usage","text":"Usage of FileInput is essentially the same as Input : use Laminas\\Http\\PhpEnvironment\\Request; use Laminas\\Filter; use Laminas\\InputFilter\\InputFilter; use Laminas\\InputFilter\\Input; use Laminas\\InputFilter\\FileInput; use Laminas\\Validator; // Description text input $description = new Input('description'); // Standard Input type // Filters are run first w/ Input $description -&gt;getFilterChain() -&gt;attach(new Filter\\StringTrim()); // Validators are run second w/ Input $description -&gt;getValidatorChain() -&gt;attach(new Validator\\StringLength(['max' =&gt; 140])); // File upload input $file = new FileInput('file'); // Special File Input type // Validators are run first w/ FileInput $file -&gt;getValidatorChain() -&gt;attach(new Validator\\File\\UploadFile()); // Filters are run second w/ FileInput $file -&gt;getFilterChain() -&gt;attach(new Filter\\File\\RenameUpload([ 'target' =&gt; './data/tmpuploads/file', 'randomize' =&gt; true, ])); // Merge $_POST and $_FILES data together $request = new Request(); $postData = array_merge_recursive( $request-&gt;getPost()-&gt;toArray(), $request-&gt;getFiles()-&gt;toArray() ); $inputFilter = new InputFilter(); $inputFilter -&gt;add($description) -&gt;add($file) -&gt;setData($postData); if ($inputFilter-&gt;isValid()) { // FileInput validators are run, but not the filters... echo \"The form is valid\\n\"; $data = $inputFilter-&gt;getValues(); // This is when the FileInput filters are run. } else { echo \"The form is not valid\\n\"; foreach ($inputFilter-&gt;getInvalidInput() as $error) { print_r ($error-&gt;getMessages()); } }","title":"Basic Usage"},{"location":"file-input/#psr-7-support","text":"Available since version 2.9.0 You may also pass an array of uploaded files from a PSR-7 ServerRequestInterface . use Psr\\Http\\Message\\ServerRequestInterface; use Laminas\\Filter; use Laminas\\InputFilter\\InputFilter; use Laminas\\InputFilter\\FileInput; use Laminas\\Validator; // File upload input $file = new FileInput('file'); $file -&gt;getValidatorChain() -&gt;attach(new Validator\\File\\UploadFile()); $file -&gt;getFilterChain() -&gt;attach(new Filter\\File\\RenameUpload([ 'target' =&gt; './data/tmpuploads/file', 'randomize' =&gt; true, ])); // Merge form and uploaded file data together // Unlike the previous example, we get the form data from `getParsedBody()`, and // the uploaded file data from `getUploadedFiles()`. // @var ServerRequestInterface $request $postData = array_merge_recursive( $request-&gt;getParsedBody(), $request-&gt;getUploadedFiles() ); $inputFilter = new InputFilter(); $inputFilter -&gt;add($file) -&gt;setData($postData); if ($inputFilter-&gt;isValid()) { // FileInput validators are run, but not the filters... echo \"The form is valid\\n\"; $data = $inputFilter-&gt;getValues(); // This is when the FileInput filters are run. } else { echo \"The form is not valid\\n\"; foreach ($inputFilter-&gt;getInvalidInput() as $error) { print_r ($error-&gt;getMessages()); } }","title":"PSR-7 Support"},{"location":"installation/","text":"This Is Only a Placeholder The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"Installation"},{"location":"installation/#this-is-only-a-placeholder","text":"The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"This Is Only a Placeholder"},{"location":"intro/","text":"Introduction laminas-inputfilter can be used to filter and validate generic sets of input data. For instance, you could use it to filter $_GET or $_POST values, CLI arguments, etc. To pass input data to the InputFilter , use the setData() method; the data must be specified using an associative array. Below is an example on how to validate the data coming from a form using the POST method. use Laminas\\InputFilter\\InputFilter; use Laminas\\InputFilter\\Input; use Laminas\\Validator; $email = new Input('email'); $email-&gt;getValidatorChain() -&gt;attach(new Validator\\EmailAddress()); $password = new Input('password'); $password-&gt;getValidatorChain() -&gt;attach(new Validator\\StringLength(8)); $inputFilter = new InputFilter(); $inputFilter-&gt;add($email); $inputFilter-&gt;add($password); $inputFilter-&gt;setData($_POST); if ($inputFilter-&gt;isValid()) { echo \"The form is valid\\n\"; } else { echo \"The form is not valid\\n\"; foreach ($inputFilter-&gt;getInvalidInput() as $error) { print_r($error-&gt;getMessages()); } } In this example, we validated the email and password values. The email must be a valid address and the password must be composed of at least 8 characters. If the input data are not valid, we report the list of invalid input using the getInvalidInput() method. You can add validators to each input using the attach() method for each validator chain. It is also possible to specify a \"validation group\", a subset of the data to be validated; this may be done using the setValidationGroup() method. You can specify the list of the input names as an array or as individual parameters. // As individual parameters $inputFilter-&gt;setValidationGroup('email', 'password'); // or as an array of names $inputFilter-&gt;setValidationGroup(['email', 'password']); You can validate and/or filter the data using the InputFilter . To filter data, use the getFilterChain() method of individual Input instances, and attach filters to the returned filter chain. Below is an example that uses filtering without validation. use Laminas\\InputFilter\\Input; use Laminas\\InputFilter\\InputFilter; $input = new Input('foo'); $input-&gt;getFilterChain() -&gt;attachByName('stringtrim') -&gt;attachByName('alpha'); $inputFilter = new InputFilter(); $inputFilter-&gt;add($input); $inputFilter-&gt;setData([ 'foo' =&gt; ' Bar3 ', ]); echo \"Before:\\n\"; echo $inputFilter-&gt;getRawValue('foo') . \"\\n\"; // the output is ' Bar3 ' echo \"After:\\n\"; echo $inputFilter-&gt;getValue('foo') . \"\\n\"; // the output is 'Bar' The getValue() method returns the filtered value of the 'foo' input, while getRawValue() returns the original value of the input. We also provide Laminas\\InputFilter\\Factory to allow initialization of the InputFilter based on a configuration array or Traversable object. Below is an example where we create a password input value with the same constraints proposed before (a string with at least 8 characters): use Laminas\\InputFilter\\Factory; use Laminas\\Validator\\NotEmpty; use Laminas\\Validator\\StringLength; $factory = new Factory(); $inputFilter = $factory-&gt;createInputFilter([ 'password' =&gt; [ 'name' =&gt; 'password', 'required' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; NotEmpty::class, ], [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 8 ], ], ], ], ]); $inputFilter-&gt;setData($_POST); echo $inputFilter-&gt;isValid() ? 'Valid form' : 'Invalid form'; The factory may be used to create not only Input instances, but also nested InputFilter s, allowing you to create validation and filtering rules for hierarchical data sets. Finally, the default InputFilter implementation is backed by a Factory . This means that when calling add() , you can provide a specification that the Factory understands, and it will create the appropriate object. You may create either Input or InputFilter objects in this fashion. use Laminas\\InputFilter\\InputFilter; use Laminas\\Validator\\NotEmpty; use Laminas\\Validator\\StringLength; $filter = new InputFilter(); // Adding a single input $filter-&gt;add([ 'name' =&gt; 'username', 'required' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; NotEmpty::class, ], [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 5 ], ], ], ]); // Adding another input filter what also contains a single input. Merging both. $filter-&gt;add([ 'type' =&gt; 'Laminas\\InputFilter\\InputFilter', 'password' =&gt; [ 'name' =&gt; 'password', 'required' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; NotEmpty::class, ], [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 8 ], ], ], ], ]); The merge() method may be used on an InputFilterInterface instance in order to add two or more filters to each other, effectively allowing you to create chains of filters. This is especially useful in object hierarchies that define a generic set of validation rules on the base object and build on these to create more specific rules. In the example below, an InputFilter is built creating name and email properties, allowing them to be re-used elsewhere. When the isValid() method is called on the object, all of the merged filters are run against the calling object in order to validate the internal properties based on our compound set of filters. use Laminas\\InputFilter\\InputFilter; /** * Filter to ensure a name property is set and &gt; 8 characters */ class NameInputFilter extends InputFilter { /** Filter body goes here **/ } /** * Filter to ensure an email property is set and &gt; 8 characters and is valid */ class EmailInputFilter extends InputFilter { /** Filter body goes here **/ } class SimplePerson { /** Member variables omitted for brevity **/ /** @var InputFilter */ protected $inputFilter; /** * Retrieve input filter * * @return InputFilter */ public function getInputFilter() { if (! $this-&gt;inputFilter) { // Create a new input filter $this-&gt;inputFilter = new InputFilter(); // Merge our inputFilter in for the email property $this-&gt;inputFilter-&gt;merge(new EmailInputFilter()); // Merge our inputFilter in for the name property $this-&gt;inputFilter-&gt;merge(new NameInputFilter()); } return $this-&gt;inputFilter; } /** * Set input filter * * @param InputFilterInterface $inputFilter * @return SimplePerson */ public function setInputFilter(InputFilterInterface $inputFilter) { $this-&gt;inputFilter = $inputFilter; return $this; } } Also see laminas-filter laminas-validator","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-inputfilter can be used to filter and validate generic sets of input data. For instance, you could use it to filter $_GET or $_POST values, CLI arguments, etc. To pass input data to the InputFilter , use the setData() method; the data must be specified using an associative array. Below is an example on how to validate the data coming from a form using the POST method. use Laminas\\InputFilter\\InputFilter; use Laminas\\InputFilter\\Input; use Laminas\\Validator; $email = new Input('email'); $email-&gt;getValidatorChain() -&gt;attach(new Validator\\EmailAddress()); $password = new Input('password'); $password-&gt;getValidatorChain() -&gt;attach(new Validator\\StringLength(8)); $inputFilter = new InputFilter(); $inputFilter-&gt;add($email); $inputFilter-&gt;add($password); $inputFilter-&gt;setData($_POST); if ($inputFilter-&gt;isValid()) { echo \"The form is valid\\n\"; } else { echo \"The form is not valid\\n\"; foreach ($inputFilter-&gt;getInvalidInput() as $error) { print_r($error-&gt;getMessages()); } } In this example, we validated the email and password values. The email must be a valid address and the password must be composed of at least 8 characters. If the input data are not valid, we report the list of invalid input using the getInvalidInput() method. You can add validators to each input using the attach() method for each validator chain. It is also possible to specify a \"validation group\", a subset of the data to be validated; this may be done using the setValidationGroup() method. You can specify the list of the input names as an array or as individual parameters. // As individual parameters $inputFilter-&gt;setValidationGroup('email', 'password'); // or as an array of names $inputFilter-&gt;setValidationGroup(['email', 'password']); You can validate and/or filter the data using the InputFilter . To filter data, use the getFilterChain() method of individual Input instances, and attach filters to the returned filter chain. Below is an example that uses filtering without validation. use Laminas\\InputFilter\\Input; use Laminas\\InputFilter\\InputFilter; $input = new Input('foo'); $input-&gt;getFilterChain() -&gt;attachByName('stringtrim') -&gt;attachByName('alpha'); $inputFilter = new InputFilter(); $inputFilter-&gt;add($input); $inputFilter-&gt;setData([ 'foo' =&gt; ' Bar3 ', ]); echo \"Before:\\n\"; echo $inputFilter-&gt;getRawValue('foo') . \"\\n\"; // the output is ' Bar3 ' echo \"After:\\n\"; echo $inputFilter-&gt;getValue('foo') . \"\\n\"; // the output is 'Bar' The getValue() method returns the filtered value of the 'foo' input, while getRawValue() returns the original value of the input. We also provide Laminas\\InputFilter\\Factory to allow initialization of the InputFilter based on a configuration array or Traversable object. Below is an example where we create a password input value with the same constraints proposed before (a string with at least 8 characters): use Laminas\\InputFilter\\Factory; use Laminas\\Validator\\NotEmpty; use Laminas\\Validator\\StringLength; $factory = new Factory(); $inputFilter = $factory-&gt;createInputFilter([ 'password' =&gt; [ 'name' =&gt; 'password', 'required' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; NotEmpty::class, ], [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 8 ], ], ], ], ]); $inputFilter-&gt;setData($_POST); echo $inputFilter-&gt;isValid() ? 'Valid form' : 'Invalid form'; The factory may be used to create not only Input instances, but also nested InputFilter s, allowing you to create validation and filtering rules for hierarchical data sets. Finally, the default InputFilter implementation is backed by a Factory . This means that when calling add() , you can provide a specification that the Factory understands, and it will create the appropriate object. You may create either Input or InputFilter objects in this fashion. use Laminas\\InputFilter\\InputFilter; use Laminas\\Validator\\NotEmpty; use Laminas\\Validator\\StringLength; $filter = new InputFilter(); // Adding a single input $filter-&gt;add([ 'name' =&gt; 'username', 'required' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; NotEmpty::class, ], [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 5 ], ], ], ]); // Adding another input filter what also contains a single input. Merging both. $filter-&gt;add([ 'type' =&gt; 'Laminas\\InputFilter\\InputFilter', 'password' =&gt; [ 'name' =&gt; 'password', 'required' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; NotEmpty::class, ], [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 8 ], ], ], ], ]); The merge() method may be used on an InputFilterInterface instance in order to add two or more filters to each other, effectively allowing you to create chains of filters. This is especially useful in object hierarchies that define a generic set of validation rules on the base object and build on these to create more specific rules. In the example below, an InputFilter is built creating name and email properties, allowing them to be re-used elsewhere. When the isValid() method is called on the object, all of the merged filters are run against the calling object in order to validate the internal properties based on our compound set of filters. use Laminas\\InputFilter\\InputFilter; /** * Filter to ensure a name property is set and &gt; 8 characters */ class NameInputFilter extends InputFilter { /** Filter body goes here **/ } /** * Filter to ensure an email property is set and &gt; 8 characters and is valid */ class EmailInputFilter extends InputFilter { /** Filter body goes here **/ } class SimplePerson { /** Member variables omitted for brevity **/ /** @var InputFilter */ protected $inputFilter; /** * Retrieve input filter * * @return InputFilter */ public function getInputFilter() { if (! $this-&gt;inputFilter) { // Create a new input filter $this-&gt;inputFilter = new InputFilter(); // Merge our inputFilter in for the email property $this-&gt;inputFilter-&gt;merge(new EmailInputFilter()); // Merge our inputFilter in for the name property $this-&gt;inputFilter-&gt;merge(new NameInputFilter()); } return $this-&gt;inputFilter; } /** * Set input filter * * @param InputFilterInterface $inputFilter * @return SimplePerson */ public function setInputFilter(InputFilterInterface $inputFilter) { $this-&gt;inputFilter = $inputFilter; return $this; } } Also see laminas-filter laminas-validator","title":"Introduction"},{"location":"optional-input-filters/","text":"Optional Input Filters Available since version 2.8.0 Normally, input filters are required , which means that if you compose them as a subset of another input filter (e.g., to validate a subset of a larger set of data), and no data is provided for that item, or an empty set of data is provided, then the input filter will consider the data invalid. If you want to allow a set of data to be empty, you can use Laminas\\InputFilter\\OptionalInputFilter . To illustrate this, let's consider a form where a user provides profile information. The user can provide an optional \"title\" and a required \"email\", and optionally details about a project they lead, which will include the project title and a URL, both of which are required if present. First, let's create an OptionalInputFilter instance for the project data: $projectFilter = new OptionalInputFilter(); $projectFilter-&gt;add([ 'name' =&gt; 'project_name', 'required' =&gt; true, ]); $projectFilter-&gt;add([ 'name' =&gt; 'url', 'required' =&gt; true, 'validators' =&gt; [ ['type' =&gt; 'uri'], ], ]); Now, we'll create our primary input filter: $profileFilter = new InputFilter(); $profileFilter-&gt;add([ 'name' =&gt; 'title', 'required' =&gt; false, ]); $profileFilter-&gt;add([ 'name' =&gt; 'email', 'required' =&gt; true, 'validators' =&gt; [ ['type' =&gt; 'EmailAddress'], ], ]); // And, finally, compose our project sub-filter: $profileFilter-&gt;add($projectFilter, 'project'); With this defined, we can now validate the following sets of data, presented in JSON for readability: Just profile information: { \"email\": \"user@example.com\", \"title\": \"Software Developer\" } null project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": null } Empty project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": {} } Valid project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": { \"project_name\": \"laminas-inputfilter\", \"url\": \"https://github.com/laminas-inputfilter\" } }","title":"Optional Input Filters"},{"location":"optional-input-filters/#optional-input-filters","text":"Available since version 2.8.0 Normally, input filters are required , which means that if you compose them as a subset of another input filter (e.g., to validate a subset of a larger set of data), and no data is provided for that item, or an empty set of data is provided, then the input filter will consider the data invalid. If you want to allow a set of data to be empty, you can use Laminas\\InputFilter\\OptionalInputFilter . To illustrate this, let's consider a form where a user provides profile information. The user can provide an optional \"title\" and a required \"email\", and optionally details about a project they lead, which will include the project title and a URL, both of which are required if present. First, let's create an OptionalInputFilter instance for the project data: $projectFilter = new OptionalInputFilter(); $projectFilter-&gt;add([ 'name' =&gt; 'project_name', 'required' =&gt; true, ]); $projectFilter-&gt;add([ 'name' =&gt; 'url', 'required' =&gt; true, 'validators' =&gt; [ ['type' =&gt; 'uri'], ], ]); Now, we'll create our primary input filter: $profileFilter = new InputFilter(); $profileFilter-&gt;add([ 'name' =&gt; 'title', 'required' =&gt; false, ]); $profileFilter-&gt;add([ 'name' =&gt; 'email', 'required' =&gt; true, 'validators' =&gt; [ ['type' =&gt; 'EmailAddress'], ], ]); // And, finally, compose our project sub-filter: $profileFilter-&gt;add($projectFilter, 'project'); With this defined, we can now validate the following sets of data, presented in JSON for readability: Just profile information: { \"email\": \"user@example.com\", \"title\": \"Software Developer\" } null project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": null } Empty project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": {} } Valid project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": { \"project_name\": \"laminas-inputfilter\", \"url\": \"https://github.com/laminas-inputfilter\" } }","title":"Optional Input Filters"},{"location":"specs/","text":"Specifications Laminas\\InputFilter allows configuration-driven creation of input filters via Laminas\\InputFilter\\InputFilterAbstractServiceFactory . This abstract factory is responsible for creating and returning an appropriate input filter given named configuration under the top-level configuration key input_filter_specs . It is registered with Laminas\\InputFilter\\InputFilterPluginManager , allowing you to pull the input filter via that plugin manager. A side effect is that forms pulled from Laminas\\Form\\FormElementManager can use these named input filters. Setup When using laminas-mvc version 2 releases, this functionality is disabled by default. To enable it, you must add the Laminas\\InputFilter\\InputFilterAbstractServiceFactory abstract factory to the Laminas\\InputFilter\\InputFilterPluginManager configuration, which is under the input_filters configuration key. return [ 'input_filters' =&gt; [ 'abstract_factories' =&gt; [ 'Laminas\\InputFilter\\InputFilterAbstractServiceFactory', ], ], ]; For Mezzio when using the configuration manager, and for laminas-mvc v3 releases, the functionality is enabled by default, assuming you are using the component installer . Example In the following code, we define configuration for an input filter named foobar : return [ 'input_filter_specs' =&gt; [ 'foobar' =&gt; [ [ 'name' =&gt; 'name', 'required' =&gt; true, 'filters' =&gt; [ [ 'name' =&gt; 'Laminas\\Filter\\StringTrim', 'options' =&gt; [], ], ], 'validators' =&gt; [], 'description' =&gt; 'Hello to name', 'allow_empty' =&gt; false, 'continue_if_empty' =&gt; false, ], ], ], ]; When creating a controller, we might then pull the InputFilterPluginManager , and retrieve the foobar input filter we've defined in order to inject it: use Laminas\\InputFilter\\InputFilterPluginManager; use Laminas\\ServiceManager\\FactoryInterface; use Laminas\\ServiceManager\\ServiceLocatorInterface; class MyValidatingControllerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $controllers) { // Retrieve the application service manager $services = $controllers-&gt;getServiceLocator(); // Retrieve the InputFilterManager $filters = $services-&gt;get(InputFilterPluginManager::class); // Instantiate the controller and pass it the foobar input filter return new MyValidatingController($filters-&gt;get('foobar')); } } And you can use it as you already did with other input filters: $inputFilter-&gt;setData([ 'name' =&gt; 'test', ]); if (! $inputFilter-&gt;isValid()) { echo 'Data invalid'; }","title":"Specifications"},{"location":"specs/#specifications","text":"Laminas\\InputFilter allows configuration-driven creation of input filters via Laminas\\InputFilter\\InputFilterAbstractServiceFactory . This abstract factory is responsible for creating and returning an appropriate input filter given named configuration under the top-level configuration key input_filter_specs . It is registered with Laminas\\InputFilter\\InputFilterPluginManager , allowing you to pull the input filter via that plugin manager. A side effect is that forms pulled from Laminas\\Form\\FormElementManager can use these named input filters.","title":"Specifications"},{"location":"specs/#setup","text":"When using laminas-mvc version 2 releases, this functionality is disabled by default. To enable it, you must add the Laminas\\InputFilter\\InputFilterAbstractServiceFactory abstract factory to the Laminas\\InputFilter\\InputFilterPluginManager configuration, which is under the input_filters configuration key. return [ 'input_filters' =&gt; [ 'abstract_factories' =&gt; [ 'Laminas\\InputFilter\\InputFilterAbstractServiceFactory', ], ], ]; For Mezzio when using the configuration manager, and for laminas-mvc v3 releases, the functionality is enabled by default, assuming you are using the component installer .","title":"Setup"},{"location":"specs/#example","text":"In the following code, we define configuration for an input filter named foobar : return [ 'input_filter_specs' =&gt; [ 'foobar' =&gt; [ [ 'name' =&gt; 'name', 'required' =&gt; true, 'filters' =&gt; [ [ 'name' =&gt; 'Laminas\\Filter\\StringTrim', 'options' =&gt; [], ], ], 'validators' =&gt; [], 'description' =&gt; 'Hello to name', 'allow_empty' =&gt; false, 'continue_if_empty' =&gt; false, ], ], ], ]; When creating a controller, we might then pull the InputFilterPluginManager , and retrieve the foobar input filter we've defined in order to inject it: use Laminas\\InputFilter\\InputFilterPluginManager; use Laminas\\ServiceManager\\FactoryInterface; use Laminas\\ServiceManager\\ServiceLocatorInterface; class MyValidatingControllerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $controllers) { // Retrieve the application service manager $services = $controllers-&gt;getServiceLocator(); // Retrieve the InputFilterManager $filters = $services-&gt;get(InputFilterPluginManager::class); // Instantiate the controller and pass it the foobar input filter return new MyValidatingController($filters-&gt;get('foobar')); } } And you can use it as you already did with other input filters: $inputFilter-&gt;setData([ 'name' =&gt; 'test', ]); if (! $inputFilter-&gt;isValid()) { echo 'Data invalid'; }","title":"Example"},{"location":"unfiltered-data/","text":"Unfiltered Data Available since version 2.10.0 On input filters, there are several methods for retrieving the data: getValues() will return all known values after filtering them. getRawValues() will return all known values with no filtering applied. getUnknown() returns the set of all unknown values (values with no corresponding input or input filter). At times, particularly when working with collections, you may want access to the complete set of original data provided to the input filter. This can be accomplished by merging the sets returned by getRawValues() and getUnknown() when working with normal input filters, but this approach breaks down when working with collections. Version 2.10.0 introduces a new interface, Laminas\\InputFilter\\UnfilteredDataInterface , for dealing with this situation. Laminas\\InputFilter\\BaseInputFilter , which forms the parent class for all shipped input filter implementations, implements the interface, which consists of the following methods: interface UnfilteredDataInterface { /** * @return array|object */ public function getUnfilteredData() { return $this-&gt;unfilteredData; } /** * @param array|object $data * @return $this */ public function setUnfilteredData($data) { $this-&gt;unfilteredData = $data; return $this; } } The setUnfilteredData() method is called by setData() with the full $data provided to that method, ensuring that getUnfilteredData() will always provide the original data with which the input filter was initialized, with no filtering applied.","title":"Unfiltered Data"},{"location":"unfiltered-data/#unfiltered-data","text":"Available since version 2.10.0 On input filters, there are several methods for retrieving the data: getValues() will return all known values after filtering them. getRawValues() will return all known values with no filtering applied. getUnknown() returns the set of all unknown values (values with no corresponding input or input filter). At times, particularly when working with collections, you may want access to the complete set of original data provided to the input filter. This can be accomplished by merging the sets returned by getRawValues() and getUnknown() when working with normal input filters, but this approach breaks down when working with collections. Version 2.10.0 introduces a new interface, Laminas\\InputFilter\\UnfilteredDataInterface , for dealing with this situation. Laminas\\InputFilter\\BaseInputFilter , which forms the parent class for all shipped input filter implementations, implements the interface, which consists of the following methods: interface UnfilteredDataInterface { /** * @return array|object */ public function getUnfilteredData() { return $this-&gt;unfilteredData; } /** * @param array|object $data * @return $this */ public function setUnfilteredData($data) { $this-&gt;unfilteredData = $data; return $this; } } The setUnfilteredData() method is called by setData() with the full $data provided to that method, ensuring that getUnfilteredData() will always provide the original data with which the input filter was initialized, with no filtering applied.","title":"Unfiltered Data"},{"location":"application-integration/usage-in-a-laminas-mvc-application/","text":"Usage in a laminas-mvc Application The following example shows one potential use case of laminas-inputfilter within a laminas-mvc based application. The example uses a module, a controller and the input filter plugin manager. The example is based on the tutorial application which builds an album inventory system. Before starting, make sure laminas-inputfilter is installed and configured . Create Input Filter Create an input filter as separate class using the init method, e.g. module/Album/src/InputFilter/QueryInputFilter.php : namespace Album\\InputFilter; use Laminas\\Filter\\ToInt; use Laminas\\I18n\\Validator\\IsInt; use Laminas\\InputFilter\\InputFilter; final class QueryInputFilter extends InputFilter { public function init(): void { // Page $this-&gt;add( [ 'name' =&gt; 'page', 'allow_empty' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; IsInt::class, ], ], 'filters' =&gt; [ [ 'name' =&gt; ToInt::class, ], ], 'fallback_value' =&gt; 1, ] ); // ‚Ä¶ } } Create Controller Create a controller class and inject the input filter plugin manager via the constructor, e.g. module/Album/Controller/AlbumController.php : namespace Album\\Controller; use Album\\InputFilter\\QueryInputFilter; use Laminas\\InputFilter\\InputFilterPluginManager; use Laminas\\Mvc\\Controller\\AbstractActionController; use function assert; final class AlbumController extends AbstractActionController { public function __construct( public readonly InputFilterPluginManager $inputFilterPluginManager ) {} public function indexAction() { $inputFilter = $this-&gt;inputFilterPluginManager-&gt;get(QueryInputFilter::class); assert($inputFilter instanceof QueryInputFilter); $inputFilter-&gt;setData($this-&gt;getRequest()-&gt;getQuery()); $inputFilter-&gt;isValid(); $filteredParams = $inputFilter-&gt;getValues(); // ‚Ä¶ } } Instantiating the Input Filter The input filter plugin manager ( Laminas\\InputFilter\\InputFilterPluginManager ) is used instead of directly instantiating the input filter to ensure to get the filter and validator plugin managers injected. This allows usage of any filters and validators registered with their respective plugin managers. Additionally, the input filter plugin manager calls the init method after instantiating the input filter, ensuring all dependencies are fully injected first. Register Input Filter and Controller If no separate factory is required for the input filter, then the input filter plugin manager will be instantiating the input filter class without prior registration. Otherwise, the input filter must be registered. To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Album/config/module.config.php : namespace Album; use Laminas\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ // Add this line Controller\\AlbumController::class =&gt; ReflectionBasedAbstractFactory::class, ], ], // ‚Ä¶ ]; The example uses the reflection factory from laminas-servicemanager to resolve the constructor dependencies for the controller class.","title":"Usage in a laminas-mvc application"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#usage-in-a-laminas-mvc-application","text":"The following example shows one potential use case of laminas-inputfilter within a laminas-mvc based application. The example uses a module, a controller and the input filter plugin manager. The example is based on the tutorial application which builds an album inventory system. Before starting, make sure laminas-inputfilter is installed and configured .","title":"Usage in a laminas-mvc Application"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#create-input-filter","text":"Create an input filter as separate class using the init method, e.g. module/Album/src/InputFilter/QueryInputFilter.php : namespace Album\\InputFilter; use Laminas\\Filter\\ToInt; use Laminas\\I18n\\Validator\\IsInt; use Laminas\\InputFilter\\InputFilter; final class QueryInputFilter extends InputFilter { public function init(): void { // Page $this-&gt;add( [ 'name' =&gt; 'page', 'allow_empty' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; IsInt::class, ], ], 'filters' =&gt; [ [ 'name' =&gt; ToInt::class, ], ], 'fallback_value' =&gt; 1, ] ); // ‚Ä¶ } }","title":"Create Input Filter"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#create-controller","text":"Create a controller class and inject the input filter plugin manager via the constructor, e.g. module/Album/Controller/AlbumController.php : namespace Album\\Controller; use Album\\InputFilter\\QueryInputFilter; use Laminas\\InputFilter\\InputFilterPluginManager; use Laminas\\Mvc\\Controller\\AbstractActionController; use function assert; final class AlbumController extends AbstractActionController { public function __construct( public readonly InputFilterPluginManager $inputFilterPluginManager ) {} public function indexAction() { $inputFilter = $this-&gt;inputFilterPluginManager-&gt;get(QueryInputFilter::class); assert($inputFilter instanceof QueryInputFilter); $inputFilter-&gt;setData($this-&gt;getRequest()-&gt;getQuery()); $inputFilter-&gt;isValid(); $filteredParams = $inputFilter-&gt;getValues(); // ‚Ä¶ } } Instantiating the Input Filter The input filter plugin manager ( Laminas\\InputFilter\\InputFilterPluginManager ) is used instead of directly instantiating the input filter to ensure to get the filter and validator plugin managers injected. This allows usage of any filters and validators registered with their respective plugin managers. Additionally, the input filter plugin manager calls the init method after instantiating the input filter, ensuring all dependencies are fully injected first.","title":"Create Controller"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#register-input-filter-and-controller","text":"If no separate factory is required for the input filter, then the input filter plugin manager will be instantiating the input filter class without prior registration. Otherwise, the input filter must be registered. To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Album/config/module.config.php : namespace Album; use Laminas\\ServiceManager\\AbstractFactory\\ReflectionBasedAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ // Add this line Controller\\AlbumController::class =&gt; ReflectionBasedAbstractFactory::class, ], ], // ‚Ä¶ ]; The example uses the reflection factory from laminas-servicemanager to resolve the constructor dependencies for the controller class.","title":"Register Input Filter and Controller"},{"location":"application-integration/usage-in-a-mezzio-application/","text":"Usage in a mezzio Application The following example shows one potential use case of laminas-inputfilter within a mezzio based application. The example uses a module, config provider configuration, laminas-servicemanager as dependency injection container, the laminas-inputfilter plugin manager and a request handler. Before starting, make sure laminas-inputfilter is installed and configured . Create Input Filter Create an input filter as separate class, e.g. src/Album/InputFilter/QueryInputFilter.php : namespace Album\\InputFilter; use Laminas\\Filter\\ToInt; use Laminas\\I18n\\Validator\\IsInt; use Laminas\\InputFilter\\InputFilter; class QueryInputFilter extends InputFilter { public function init() { // Page $this-&gt;add( [ 'name' =&gt; 'page', 'allow_empty' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; IsInt::class, ], ], 'filters' =&gt; [ [ 'name' =&gt; ToInt::class, ], ], 'fallback_value' =&gt; 1, ] ); // ‚Ä¶ } } Using Input Filter Create Handler Using the input filter in a request handler, e.g. src/Album/Handler/ListHandler.php : namespace Album\\Handler; use Album\\InputFilter\\QueryInputFilter; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Psr\\Http\\Message\\ResponseInterface; use Laminas\\InputFilter\\InputFilterInterface; use Mezzio\\Template\\TemplateRendererInterface; class ListHandler implements RequestHandlerInterface { /** @var InputFilterInterface */ private $inputFilter; /** @var TemplateRendererInterface */ private $renderer; public function __construct( InputFilterInterface $inputFilter, TemplateRendererInterface $renderer ) { $this-&gt;inputFilter = $inputFilter; $this-&gt;renderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { $this-&gt;inputFilter-&gt;setData($request-&gt;getQueryParams()); $this-&gt;inputFilter-&gt;isValid(); $filteredParams = $this-&gt;inputFilter-&gt;getValues(); // ‚Ä¶ return new HtmlResponse($this-&gt;renderer-&gt;render( 'album::list', [] )); } } Create Factory for Handler Fetch the QueryInputFilter from the input filter plugin manager in a factory, e.g. src/Album/Handler/ListHandlerFactory.php : namespace Album\\Handler; use Album\\InputFilter\\QueryInputFilter; use Psr\\Container\\ContainerInterface; use Laminas\\InputFilter\\InputFilterPluginManager; class ListHandlerFactory { public function __invoke(ContainerInterface $container) { /** @var InputFilterPluginManager $pluginManager */ $pluginManager = $container-&gt;get(InputFilterPluginManager::class); $inputFilter = $pluginManager-&gt;get(QueryInputFilter::class); return new ListHandler( $inputFilter, $container-&gt;get(TemplateRendererInterface::class) ); } } Instantiating the InputFilter The InputFilterPluginManager is used instead of directly instantiating the input filter to ensure to get the filter and validator plugin managers injected. This allows usage of any filters and validators registered with their respective plugin managers. Additionally the InputFilterPluginManager calls the init method after instantiating the input filter, ensuring all dependencies are fully injected first. Register Input Filter and Handler Extend the configuration provider of the module to register the input filter and the request handler, e.g. src/Album/ConfigProvider.php : namespace Album; class ConfigProvider { public function __invoke() : array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), 'input_filters' =&gt; $this-&gt;getInputFilters(), // &lt;-- Add this line ]; } public function getDependencies() : array { return [ 'factories' =&gt; [ Handler\\ListHandler::class =&gt; Handler\\ListHandlerFactory::class, // &lt;-- Add this line // ‚Ä¶ ], ]; } // Add the following method public function getInputFilters() : array { return [ 'factories' =&gt; [ InputFilter\\QueryInputFilter::class =&gt; InvokableFactory::class, ], ]; } // ‚Ä¶ }","title":"Usage in a mezzio application"},{"location":"application-integration/usage-in-a-mezzio-application/#usage-in-a-mezzio-application","text":"The following example shows one potential use case of laminas-inputfilter within a mezzio based application. The example uses a module, config provider configuration, laminas-servicemanager as dependency injection container, the laminas-inputfilter plugin manager and a request handler. Before starting, make sure laminas-inputfilter is installed and configured .","title":"Usage in a mezzio Application"},{"location":"application-integration/usage-in-a-mezzio-application/#create-input-filter","text":"Create an input filter as separate class, e.g. src/Album/InputFilter/QueryInputFilter.php : namespace Album\\InputFilter; use Laminas\\Filter\\ToInt; use Laminas\\I18n\\Validator\\IsInt; use Laminas\\InputFilter\\InputFilter; class QueryInputFilter extends InputFilter { public function init() { // Page $this-&gt;add( [ 'name' =&gt; 'page', 'allow_empty' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; IsInt::class, ], ], 'filters' =&gt; [ [ 'name' =&gt; ToInt::class, ], ], 'fallback_value' =&gt; 1, ] ); // ‚Ä¶ } }","title":"Create Input Filter"},{"location":"application-integration/usage-in-a-mezzio-application/#using-input-filter","text":"","title":"Using Input Filter"},{"location":"application-integration/usage-in-a-mezzio-application/#register-input-filter-and-handler","text":"Extend the configuration provider of the module to register the input filter and the request handler, e.g. src/Album/ConfigProvider.php : namespace Album; class ConfigProvider { public function __invoke() : array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), 'input_filters' =&gt; $this-&gt;getInputFilters(), // &lt;-- Add this line ]; } public function getDependencies() : array { return [ 'factories' =&gt; [ Handler\\ListHandler::class =&gt; Handler\\ListHandlerFactory::class, // &lt;-- Add this line // ‚Ä¶ ], ]; } // Add the following method public function getInputFilters() : array { return [ 'factories' =&gt; [ InputFilter\\QueryInputFilter::class =&gt; InvokableFactory::class, ], ]; } // ‚Ä¶ }","title":"Register Input Filter and Handler"},{"location":"cookbook/enhanced-type-inference/","text":"Using Laminas InputFilter with Static Analysis Tools It can be tedious to assert that the array returned by a given input filter contains the keys and value types that you would expect before using those values in your domain. If you use static analysis tools such as Psalm or PHPStan, InputFilterInterface defines a generic template that can be used to refine the types you receive from the getValues() method. &lt;?php namespace My; use Laminas\\Filter\\ToInt; use Laminas\\Filter\\ToNull; use Laminas\\I18n\\Validator\\IsInt; use Laminas\\InputFilter\\InputFilter;use Laminas\\Validator\\GreaterThan; /** * @psalm-type ValidPayload = array{ * anInteger: int&lt;1, max&gt;, * } * @extends InputFilter&lt;ValidPayload&gt; */ final class SomeInputFilter extends InputFilter { public function init(): void { $this-&gt;add([ 'name' =&gt; 'anInteger', 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; ToNull::class], ['name' =&gt; ToInt::class], ], 'validators' =&gt; [ ['name' =&gt; NotEmpty::class], ['name' =&gt; IsInt::class], [ 'name' =&gt; GreaterThan::class, 'options' =&gt; [ 'min' =&gt; 1, ], ], ], ]); } } With the above input filter specification, one can guarantee that, if the input payload is deemed valid, then you will receive an array with the expected shape from InputFilter::getValues() , therefore, your static analysis tooling will not complain when you pass that value directly to something that expects a positive-int , for example: /** * @param positive-int $value * @return positive-int */ function addTo5(int $value): int { return $value + 5; } $filter = new SomeInputFilter(); $filter-&gt;setData(['anInteger' =&gt; '123']); assert($filter-&gt;isValid()); $result = addTo5($filter-&gt;getValues()['anInteger']); Further reading Psalm documentation on array shapes Psalm documentation on type aliases PHPStan documentation on array shapes PHPStan documentation on type aliases","title":"Using Static Analysis tools with laminas-inputfilter"},{"location":"cookbook/enhanced-type-inference/#using-laminas-inputfilter-with-static-analysis-tools","text":"It can be tedious to assert that the array returned by a given input filter contains the keys and value types that you would expect before using those values in your domain. If you use static analysis tools such as Psalm or PHPStan, InputFilterInterface defines a generic template that can be used to refine the types you receive from the getValues() method. &lt;?php namespace My; use Laminas\\Filter\\ToInt; use Laminas\\Filter\\ToNull; use Laminas\\I18n\\Validator\\IsInt; use Laminas\\InputFilter\\InputFilter;use Laminas\\Validator\\GreaterThan; /** * @psalm-type ValidPayload = array{ * anInteger: int&lt;1, max&gt;, * } * @extends InputFilter&lt;ValidPayload&gt; */ final class SomeInputFilter extends InputFilter { public function init(): void { $this-&gt;add([ 'name' =&gt; 'anInteger', 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; ToNull::class], ['name' =&gt; ToInt::class], ], 'validators' =&gt; [ ['name' =&gt; NotEmpty::class], ['name' =&gt; IsInt::class], [ 'name' =&gt; GreaterThan::class, 'options' =&gt; [ 'min' =&gt; 1, ], ], ], ]); } } With the above input filter specification, one can guarantee that, if the input payload is deemed valid, then you will receive an array with the expected shape from InputFilter::getValues() , therefore, your static analysis tooling will not complain when you pass that value directly to something that expects a positive-int , for example: /** * @param positive-int $value * @return positive-int */ function addTo5(int $value): int { return $value + 5; } $filter = new SomeInputFilter(); $filter-&gt;setData(['anInteger' =&gt; '123']); assert($filter-&gt;isValid()); $result = addTo5($filter-&gt;getValues()['anInteger']);","title":"Using Laminas InputFilter with Static Analysis Tools"},{"location":"cookbook/enhanced-type-inference/#further-reading","text":"Psalm documentation on array shapes Psalm documentation on type aliases PHPStan documentation on array shapes PHPStan documentation on type aliases","title":"Further reading"},{"location":"cookbook/input-filter-in-forms/","text":"Using Input Filters in Forms of laminas-form The following examples show two potential use cases of laminas-inputfilter within laminas-form . Define the Input Filter in a Form An input filter can be defined directly in a form class itself, using Laminas\\InputFilter\\InputFilterProviderInterface . This interface provides one method ( getInputFilterSpecification() ) that is used by a form to create an input filter. Create a form as a separate class , define the init method , implement the interface Laminas\\InputFilter\\InputFilterProviderInterface , and define its inputs via a configuration array; as an example, consider the following definition in a file found at module/Album/src/Form/AlbumForm.php : namespace Album\\Form; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\Form\\Element\\Text; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Validator\\StringLength; final class AlbumForm extends Form implements InputFilterProviderInterface { public function init(): void { // Add form elements $this-&gt;add([ 'name' =&gt; 'title', 'type' =&gt; Text::class, 'options' =&gt; [ 'label' =&gt; 'Title', ], ]); // ‚Ä¶ } public function getInputFilterSpecification(): array { return [ // Add inputs [ 'name' =&gt; 'title', 'filters' =&gt; [ ['name' =&gt; StripTags::class], ['name' =&gt; StringTrim::class], ], 'validators' =&gt; [ [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 1, 'max' =&gt; 100, ], ], ], ], // ‚Ä¶ ]; } } Adding an Input Filter Defined as a Separate Class to a Form Create Input Filter Create an input filter as a separate class , e.g. module/Album/src/InputFilter/AlbumInputFilter.php : namespace Album\\InputFilter; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\Validator\\StringLength; use Laminas\\InputFilter\\InputFilter; final class AlbumInputFilter extends InputFilter { public function init(): void { // Add inputs $this-&gt;add( [ 'name' =&gt; 'title', 'filters' =&gt; [ ['name' =&gt; StripTags::class], ['name' =&gt; StringTrim::class], ], 'validators' =&gt; [ [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 1, 'max' =&gt; 100, ], ], ], ] ); // ‚Ä¶ } } Create Form and Add Input Filter An input filter can be added directly in a form class itself, using the class name of the input filter or whatever name the input filter is registered under. Create a form as a separate class, define its init method, and set the input filter via the setInputFilterByName() method of Laminas\\Form\\Form , e.g. module/Album/src/Form/AlbumForm.php : namespace Album\\Form; use Album\\InputFilter\\AlbumInputFilter; use Laminas\\Form\\Element\\Text; use Laminas\\Form\\Form; final class AlbumForm extends Form { public function init(): void { // Set the input filter $this-&gt;setInputFilterByName(AlbumInputFilter::class); // Add form elements $this-&gt;add([ 'name' =&gt; 'title', 'type' =&gt; Text::class, 'options' =&gt; [ 'label' =&gt; 'Title', ], ]); // ‚Ä¶ } }","title":"Using Input Filters in Forms of laminas-form"},{"location":"cookbook/input-filter-in-forms/#using-input-filters-in-forms-of-laminas-form","text":"The following examples show two potential use cases of laminas-inputfilter within laminas-form .","title":"Using Input Filters in Forms of laminas-form"},{"location":"cookbook/input-filter-in-forms/#define-the-input-filter-in-a-form","text":"An input filter can be defined directly in a form class itself, using Laminas\\InputFilter\\InputFilterProviderInterface . This interface provides one method ( getInputFilterSpecification() ) that is used by a form to create an input filter. Create a form as a separate class , define the init method , implement the interface Laminas\\InputFilter\\InputFilterProviderInterface , and define its inputs via a configuration array; as an example, consider the following definition in a file found at module/Album/src/Form/AlbumForm.php : namespace Album\\Form; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\Form\\Element\\Text; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Validator\\StringLength; final class AlbumForm extends Form implements InputFilterProviderInterface { public function init(): void { // Add form elements $this-&gt;add([ 'name' =&gt; 'title', 'type' =&gt; Text::class, 'options' =&gt; [ 'label' =&gt; 'Title', ], ]); // ‚Ä¶ } public function getInputFilterSpecification(): array { return [ // Add inputs [ 'name' =&gt; 'title', 'filters' =&gt; [ ['name' =&gt; StripTags::class], ['name' =&gt; StringTrim::class], ], 'validators' =&gt; [ [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 1, 'max' =&gt; 100, ], ], ], ], // ‚Ä¶ ]; } }","title":"Define the Input Filter in a Form"},{"location":"cookbook/input-filter-in-forms/#adding-an-input-filter-defined-as-a-separate-class-to-a-form","text":"","title":"Adding an Input Filter Defined as a Separate Class to a Form"}]}